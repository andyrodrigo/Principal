
<html>
<head>
<meta charset="UTF-8"/>
<title>PDI</h1></title>
</head>
<body>
 <h1>Processamento Digital de Imagens</h1>
 
 1. Exercícios:<br/>
 <br/>
 a) Regiões<br/>
  
 <pre class='brush: cpp'>
#include &lt iostream &gt
#include &lt opencv2/opencv.hpp &gt

using namespace std;
using namespace cv;

//Regions

int main()
{
	cout << "EXERCICIO 01 - REGIONS" << endl << endl;
	
	Mat imagem;
	Vec3b val;
	imagem = imread("canguru.png", CV_LOAD_IMAGE_GRAYSCALE);
	if (!imagem.data) {
		cout << ("Nao abriu arquivo") << endl;
	}
	else {
		int P1x, P1y, P2x, P2y;
		int altura = imagem.size().height;
		int largura = imagem.size().width;
		cout << "A imagem tem altura " << altura << " e largura " << largura << endl << endl;
		cout << "Digite um ponto P1." << endl;
		while (1) {
			cout << "Coordenada X: ";
			cin >> P1x;
			if (P1x > 0 && P1x < largura) {
				break;
			}else {
				cout << "O Valor deve estar entre 1 e " << largura << endl;
			}
		}
		while (1) {
			cout << "Coordenada Y: ";
			cin >> P1y;
			if (P1y > 0 && P1y < altura) {
				break;
			}
			else {
				cout << "O Valor deve estar entre 1 e " << altura << endl;
			}
		}
		cout << endl << "Digite um ponto P2." << endl;
		while (1) {
			cout << "Coordenada X: ";
			cin >> P2x;
			if (P2x > 0 && P2x < largura) {
				break;
			}
			else {
				cout << "O Valor deve estar entre 1 e " << largura << endl;
			}
		}
		while (1) {
			cout << "Coordenada Y: ";
			cin >> P2y;
			if (P2y > 0 && P2y < altura) {
				break;
			}
			else {
				cout << "O Valor deve estar entre 1 e " << altura << endl;
			}
		}
		imshow("janela (Original)", imagem);

		waitKey(3000);

		//Negativo de uma imagem eh: 255 - valor de cor do pixel.
		for (int i = P1x; i < P2x ; i++) {
			for (int j = P1y ;j < P2y ;j++) {
				imagem.at&ltuchar&gt(i, j) = 255 - imagem.at&ltuchar&gt(i, j);
			}
		}
		imshow("janela (Modificada)", imagem);
	}
	waitKey();
	return 0;
}
  </pre>
 
  <img src="tela.png"><br/>
  <img src="cang1.png">
  <img src="cang2.png">
  <br/>
  
  <br/>
  b) Troca regiões<br/>
  
  <pre class='brush: cpp'>
#include &lt iostream &gt
#include &lt opencv2/opencv.hpp &gt

using namespace std;
using namespace cv;

//Troca Regioes

int main()
{
	cout << "EXERCICIO 02 - TROCA REGIOES" << endl << endl;
	
	Mat imagem;
	Mat imagemAUX;
	
	imagem = imread("canguru.png", CV_LOAD_IMAGE_GRAYSCALE);
	imagemAUX = imread("canguru.png", CV_LOAD_IMAGE_GRAYSCALE);
	if (!imagem.data) {
		cout << ("Nao abriu arquivo") << endl;
	}
	else {

		imshow("janela (Original)", imagem);

		waitKey(3000);

		int P1x, P1y, P2x, P2y;
		int altura = imagem.size().height;
		int largura = imagem.size().width;
		int meiaAltura = altura / 2;
		int meiaLargura = largura / 2;
		
		//Primeiro Quadrante
		for (int i = 0; i < meiaAltura; i++) {
			for (int j = 0; j < meiaLargura; j++) {
				imagem.at&ltuchar&gt(i, j) = imagemAUX.at&ltuchar&gt(i + meiaAltura, j + meiaLargura);
			}
		}
		//Segundo Quadrante
		for (int i = meiaAltura; i < altura; i++) {
			for (int j = 0; j < meiaLargura; j++) {
				imagem.at&ltuchar&gt(i, j) = imagemAUX.at&ltuchar&gt(i - meiaAltura, j + meiaLargura);
			}
		}
		//Terceiro Quadrante
		for (int i = 0; i < meiaAltura; i++) {
			for (int j = meiaLargura; j < largura; j++) {
				imagem.at&ltuchar&gt(i, j) = imagemAUX.at&ltuchar&gt(i + meiaAltura, j - meiaLargura);
			}
		}
		//Quarto Quadrante
		for (int i = meiaAltura; i < altura; i++) {
			for (int j = meiaLargura; j < largura; j++) {
				imagem.at&ltuchar&gt(i, j) = imagemAUX.at&ltuchar&gt(i - meiaAltura, j - meiaLargura);
			}
		}
		imshow("janela (Modificada)", imagem);
	}
	waitKey();
	return 0;
}
  </pre>
  <img src="cangurutrocado.png"><br/>
  
  <br/>
    c) Corrigindo Labeling<br/>
      No programa labeling.cpp, se houver o caso em que haja mais de 255 objetos na imagem, A rotulação chegará a um valor que atrapalhará o processo. O problema pode ser corrigido alterando a linha de código abaixo:<br/>
      <pre class='brush: cpp'>
      floodFill(image,p,nobjects);
      </pre>
      fixando o valor da variavel, mudamos para, por exemplo:
      <pre class='brush: cpp'>
      floodFill(imagem, p, 100);
      </pre>
      
 <br/>     
      d) Conta Buracos<br/>
  <pre class='brush: cpp'>
#include &lt iostream &gt
#include &lt opencv2/opencv.hpp &gt

using namespace std;
using namespace cv;

int main()
{
	cout << "03 CONTA BURACOS" << endl << endl;
	
	Mat imagem, mask;
	int altura, largura;
	int nobjects, nburaco;
	CvPoint p;

	imagem = imread("bolhas.png", CV_LOAD_IMAGE_GRAYSCALE);

	if (!imagem.data) {
		cout << "imagem nao carregou corretamente\n";
		return(-1);
	}
	altura = imagem.size().height;
	largura = imagem.size().width;

	p.x = 0;
	p.y = 0;

	//Apaga Buracos nas borda verticais
	for (int i = 0; i < altura; i++) {
		p.x = 0;
		if (imagem.at&ltuchar&gt(i, p.x) == 255) {
			p.y = i;
			floodFill(imagem, p, 0);
		}
		p.x = largura - 1;
		if (imagem.at&ltuchar&gt(i, p.x) == 255) {
			p.y = i;
			floodFill(imagem, p, 0);
		}
	}
	//Apaga Buracos nas borda Horizontais
	for (int i = 0; i < largura; i++) {
		p.y = 0;
		if (imagem.at&ltuchar&gt(p.y, i) == 255) {
			p.x = i;
			floodFill(imagem, p, 0);
		}
		p.y = altura - 1;
		if (imagem.at&ltuchar&gt(p.y, i) == 255) {
			p.x = i;
			floodFill(imagem, p, 0);
		}
	}
	p.x = 0;
	p.y = 0;
	//Pinta o fundo de outra cor diferente do preto original
	floodFill(imagem, p, 1);
	// Conta quantos objetos tem
	nobjects = 0;
	for (int i = 0; i < altura; i++) {
		for (int j = 0; j < largura; j++) {
			if (imagem.at&ltuchar&gt(i, j) == 255) {
				// achou um objeto
				nobjects++;
				p.x = j;
				p.y = i;
				floodFill(imagem, p, 100);
				
			}
		}
	}
	p.x = 0;
	p.y = 0;
	nburaco = 0;
	for (int i = 0; i < altura; i++) {
		for (int j = 0; j < largura; j++) {
			if (imagem.at&ltuchar&gt(i, j) == 0 && imagem.at<uchar>(i, j - 1) == 100) {
				// achou um buraco
				nburaco++;
				p.x = j;
				p.y = i;
				floodFill(imagem, p, 150);
				p.x = j - 1;
				floodFill(imagem, p, 50);
			}
		}
	}
	cout << "A imagem possui " << nobjects << " objetos, " << nburaco <<" com buracos." << endl;
	imshow("imagem", imagem);
	imwrite("novo.png", imagem);
	waitKey();

	return 0;
}
  </pre>
  
  <br/>
        c) Corrigindo Labeling<br/>
  <pre class='brush: cpp'>
  </pre>
  
</body>
</html>

